<!DOCTYPE html>
<html>

  <head>
	<meta name="generator" content="Hugo 0.54.0" />

  <title>
      
      Brash &amp; Plucky
      
  </title>

</head>


  <body>

    

	
<div class="h-feed">

	
	
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/04/16/im-currently-swimming.html">Trimmed NURBS</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/04/16/im-currently-swimming.html" class="u-url"><time class="dt-published" datetime="2022-04-16 07:44:00 &#43;0200">Apr 16, 2022</time></a>

        <div class="e-content">
         	<p>I&rsquo;m currently swimming in an ocean of NURBS with their trimming loops. This is experimental work for NURBS rendering in Maverick Render.</p>

<p><img src="uploads/2022/b0526fdbcf.png" width="600" height="519" alt="" /></p>

<p><img src="uploads/2022/162c080550.png" width="600" height="616" alt="" /></p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/04/12/a-couple-of.html">Lattice-Boltzmann Method (LBM)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/04/12/a-couple-of.html" class="u-url"><time class="dt-published" datetime="2022-04-12 23:52:00 &#43;0200">Apr 12, 2022</time></a>

        <div class="e-content">
         	<p>A couple of weekends ago I was tinkering with fluid dynamics and implemented a few compute shaders in Unity. Among the ones I implemented, my favorite is the Lattice-Boltzmann Method featured here.</p>

<p><img src="uploads/2022/407fc47c9b.jpg" width="575" height="345" alt="" /></p>

<p>This early implementation allows to draw SDF entities in the simulation space behaving as blockers, inflows or outflows. I intend to expand on the features, but most likely at a slow pace, because this is a no-rush side-project. But I definitely wish to post now and then about my progress.</p>

<video controls="controls" playsinline="playsinline" src="https://www.brashandplucky.com/uploads/2022/a990f72c82.mp4" width="586" height="356" poster="https://www.brashandplucky.com/uploads/2022/ed97e69515.png" preload="none"></video>

<p>I also hope to find some spare time soon to write a quick article on how to implement an LBM cellular automata from a light-on-maths perspective.</p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/04/12/224748.html">Colorful pet project</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/04/12/224748.html" class="u-url"><time class="dt-published" datetime="2022-04-12 22:47:00 &#43;0200">Apr 12, 2022</time></a>

        <div class="e-content">
         	<p>Some pet project I am making some progress on. More info soon. Definitely. Maybe.</p>

<p><img src="uploads/2022/49bd635e27.jpg" width="600" height="576" alt="" /></p>

<p><strong>[EDIT] I had to install a micro.blog plug-in so Twitter cards display the main post image when cross-posting to Twitter.</strong> Apologies for the multiple test posts.</p>

<p><strong>[EDIT] Here&rsquo;s a hint.</strong> It&rsquo;s a cutsie CSG-based Solid modeling experiment in Unity Editor.</p>

<p><img src="uploads/2022/ce58ca5845.gif" width="600" height="623" alt="" /></p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/02/11/topology-fun.html">Topology fun</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/02/11/topology-fun.html" class="u-url"><time class="dt-published" datetime="2022-02-12 00:17:00 &#43;0200">Feb 12, 2022</time></a>

        <div class="e-content">
         	<p>Recently I have been revisiting in my spare time one of my favorite subjects: <a href="https://en.wikipedia.org/wiki/Topology">topology</a>. I will probably be posting some stuff about topological operators, subdivision surfaces, DCEL structures, irregular tilings and such things in the near future.</p>

<p>Below: A little demo I&rsquo;ve written that supports an extended flavor of <a href="https://en.wikipedia.org/wiki/Conway_polyhedron_notation">Conway&rsquo;s notation</a> for polyhedra: <code>adotaocD</code>.</p>

<p><img src="uploads/2022/e9cee91a82.gif" width="533" height="533" alt="" /></p>

<p><strong>[EDIT] I paused this pet project for the time being&hellip;</strong> because the 2022.2 release of <a href="https://maverickrender.com/">Maverick</a> has virtually blown all my productivity hours away. But I plan to write some entries on topological operators at some point further into this year.</p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/30/old-mlt-experiments.html">Old MLT experiments</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/30/old-mlt-experiments.html" class="u-url"><time class="dt-published" datetime="2022-01-30 05:52:00 &#43;0200">Jan 30, 2022</time></a>

        <div class="e-content">
         	

<p><strong>These are some very old MLT tests that I found on my hard drive today.</strong></p>

<p><a href="https://en.wikipedia.org/wiki/Metropolis_light_transport">Metropolis Light Transport</a> (MLT) is a global illumination variant of the <a href="https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm">Metropolis-Hastings</a> algorithm for <a href="https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo">Markov-Chain Monte Carlo</a> (MCMC).</p>

<p>In a nutshell, MCMC algorithms explore the neighborhood of a Monte Carlo sample by jittering (mutating) said sample. A metric is then used to define <em>how good</em> a sample is, so the next mutation is accepted or rejected based on how good it is compared to the current sample. This leads to a <em>random-walk</em> in the space of samples which tends to crawl up in the increasing direction of the metric used.</p>

<p>This method biases sampling towards successful samples. So a bit of statistics juggling is required to counter that bias. The link below is a seminal paper that beautifully describes the nuts and bolts of this process. The idea presented there is to jitter samples, not in sample space directly, but in quasi-random number tuples space instead:</p>

<p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.21.4826&amp;rep=rep1&amp;type=pdf">Simple and Robust Mutation Strategy for Metropolis Light
Transport Algorithm</a></p>

<p>In the particular case of MLT, samples are random light paths, and the metric used is the amount of light energy transported by a path. This can be implemented on top of regular Path Tracing. Arion was the first (?) commercial render engine that did this on the GPU back in 2012 or so.</p>

<p>MLT has fallen out of favor over the years (path guiding is all the rage these days). But MLT proved to be a competent <em>universal solution</em> to global illumination, being capable of boosting path tracing so it could efficiently solve even the hardest cases, such as refractive caustics.</p>

<p>The beauty of MLT is that it requires 0 configuration from the user and does not need any additional memory for data structures. The main drawbacks are the <em>ugly splotchy and non-uniform look of noise</em>, as compared to regular path tracing, and the inability to guarantee noise <em>stability across animation frames</em>.</p>

<h2 id="experiments-in-2d">Experiments in 2D</h2>

<p>Before I implemented MLT in Arion, I did some MCMC simulations with 2D sampling. In the videos below I used the <code>(x,y)</code> coords of pixels as samples, and the grayscale luminance <code>Y</code> of the image as the metric. The goal of the mutations here is to reconstruct the image by sampling harder in the directions of higher luminance.</p>

<p>MCMC is prone to getting stuck for long amounts of time in local maxima. The practical solution proposed in the above paper is to introduce a <em>plarge</em> probability that kicks the sampling scheme and sends the next sample to a purely random position in the sample space. The videos below visualize this very well I think.</p>

<p><em>Mutating in QRN tuple space without plarge</em> - <a href="https://youtu.be/55CXyRqXIJU">Watch on Youtube</a></p>

<p><img src="uploads/2022/51d1741ea4.png" width="512" height="512" alt="" /></p>

<p><em>Mutating in QRN tuple space with plarge</em> - <a href="https://youtu.be/RJIDema8mz4">Watch on Youtube</a></p>

<p><img src="uploads/2022/4e2da71675.png" width="512" height="512" alt="" /></p>

<p><em>MLT reconstructing a grayscale image</em> - <a href="https://youtu.be/WYvMGtWp4N4">Watch on Youtube</a></p>

<p><img src="uploads/2022/c8db37186e.png" width="550" height="362" alt="" /></p>

<p>Implementing MLT successfully in <a href="https://maverickrender.com">our render engine</a> did require some specialization in our sampling routines. I won&rsquo;t get into the details, but basically, since mutations happen in the random tuples that generate the paths, you expect continuous mutations in the tuples to produce continuous changes in the generated paths. So all samplers involved must avoid discontinuities in the <code>[QRN&lt;-&gt;path]</code> bijection.</p>

<h2 id="back-in-time">Back in time</h2>

<p>Some MLT-heavy images rendered in Arion back then:</p>

<p><img src="uploads/2022/dc95e60f9e.jpg" width="600" height="429" alt="" /></p>

<p><img src="uploads/2022/94c3cb35a8.jpg" width="600" height="337" alt="" /></p>

<p><img src="uploads/2022/45f4967f73.jpg" width="600" height="337" alt="" /></p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/29/uniform-vs-stratified.html">Uniform vs. stratified (2015-03-10)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/29/uniform-vs-stratified.html" class="u-url"><time class="dt-published" datetime="2022-01-29 16:34:38 &#43;0200">Jan 29, 2022</time></a>

        <div class="e-content">
         	<p><strong>[EDIT] This post was migrated from my blog from 2011‚Ä¶</strong></p>

<p>This is a classic subject in numerical (Monte Carlo) integration.</p>

<p><em>Uniform 2D distribution vs. Halton series for the first 2 dimensions</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/c5fd50d371.png" width="600" height="300" alt="" /></p>

<p>To the left: 32768 points in a 512√ó512 image using a uniform random number generator (Mersenne Twister). To the right, the first 32768 pairs in the Halton series, using dimensions #0 and #1. Click to enlarge!</p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/29/filling-of-missing.html">Filling of missing image pixels (2015-05-28)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/29/filling-of-missing.html" class="u-url"><time class="dt-published" datetime="2022-01-29 16:01:00 &#43;0200">Jan 29, 2022</time></a>

        <div class="e-content">
         	

<p><strong>[EDIT] This post was migrated from my blog from 2011‚Ä¶</strong></p>

<p>Here‚Äôs what we could call a mean pyramid of the 512√ó512 <a href="https://en.wikipedia.org/wiki/Lena_Fors%C3%A9n">Lena image</a>. <em>i.e.</em>, a sequence of progressive 1:2 downscalings, where each pixel in the i-th downscaled level is the average of the corresponding 4 pixels in the previous level. For people familiar with OpenGL and such, this is what happens when the mipmaps for a texture map are computed:</p>

<p><em>The 9+1 mipmap levels in the 512√ó512 Lena image</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/8a609e57da.png" width="512" height="768" alt="" /></p>

<p>There are many smart, efficient, and relatively simple algorithms based on multi-resolution image pyramids. Modern GPUs can deal with upscaling and downscaling of RGB/A images at the speed of light, so usually such algorithms can be implemented at interactive or even real-time framerates.</p>

<p>Here is the result of upscaling all the mip levels of the Lena image by doing progressive 2:1 bi-linear upscalings until the original resolution is reached:</p>

<p><em>Upscaled mipmap levels</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/8d745486da.png" width="600" height="600" alt="" /></p>

<p>Note the characteristic ‚Äúblocky‚Äù (bi-linear) appearance, specially evident in the images of the second row.</p>

<p>Lately, I have been doing some experimentation with <strong>pixel extrapolation</strong> algorithms that ‚Äúrestore‚Äù the missing pixels in an incomplete image for a 2D DOF filter based on the Depth AOV.</p>

<p>My pixel extrapolation algorithm works in 2 stages:</p>

<ol>
<li>The first stage (analysis) prepares the mean pyramid of the source image by doing progressive 1:2 downscalings. Only the meaningful (not-a-hole) pixels in each 2x2 packet are averaged down. If a 2x2 packet does not have any meaningful pixels, a hole is passed to the next (lower) level.</li>
<li>The second stage (synthesis) starts at the smallest level and goes up, leaving meaningful pixels intact, while replacing holes by upscaled data from the previous (lower) level.</li>
</ol>

<p><em>Mean pyramid (with holes)</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/ab15c77d06.png" width="512" height="768" alt="" /></p>

<p>Note that the analysis stage can stop as soon as a mip level doesn‚Äôt have any holes.</p>

<p>Here is the full algorithm, successfully filling the missing pixels in the image.</p>

<p><em>Mean pyramid (filled)</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/92cab1f783.png" width="512" height="768" alt="" /></p>

<h2 id="conclusions">Conclusions:</h2>

<p>This algorithm can be implemented in an extremely efficient fashion on the GPU, and allows for fantastic parallelization on the CPU as well. The locality of color/intensity is preserved reasonably well, although holes become smears of color ‚Äútoo easily‚Äù.</p>

<p>A small (classic) inconvenience is that the source image must be pre-padded to a power-of-2 size for the progressive 1:2 downscalings to be well defined. I picked an image that is a power-of-2 in size already in the above examples.</p>

<p>TL;DR: Given the ease of implementation and the extreme potential in terms of efficiency, the results are quite decent for many applications.</p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/29/playing-with-the.html">Playing with the Fourier Transform (2016-07-28)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/29/playing-with-the.html" class="u-url"><time class="dt-published" datetime="2022-01-29 16:01:00 &#43;0200">Jan 29, 2022</time></a>

        <div class="e-content">
         	

<p><strong>[EDIT] This post was migrated from my blog from 2011‚Ä¶</strong></p>

<p>The beauty and power of the <a href="https://en.wikipedia.org/wiki/Fourier_transform">Fourier Transform</a> never cease to amaze me. And since several effects in <a href="http://www.arionfx.com">ArionFX</a> are based on it, I have had to play with it a lot in recent times.</p>

<p>As explained in a previous post, diffraction patterns (<em>e.g.,</em> the glare simulated in ArionFX for Photoshop) come from the Fourier Transform of the lens aperture. I will use the FT of an aperture mask for visualization in this post.</p>

<p>I will use pow-2 square sizes (my FT implementation is an FFT). Let‚Äôs start by this Aperture x Obstacle map output directly from ArionFX for Photoshop v3.5.0.</p>

<p><em>Aperture x Obstacle mask, rasterized @ 512√ó512</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/0923ef842a.png" width="512" height="512" alt="" /></p>

<p>The Fourier Transform of that image, rasterized at that size in said 512√ó512 buffer, is the following.</p>

<p><em>FT of the mask above</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/91b6b3b6d3.png" width="512" height="512" alt="" /></p>

<p>The faux-color is done on the magnitude of each complex number in the FT. All the FT images in this post are normalized equally, and offset to look ‚Äúcentered‚Äù around the mid-pixel.</p>

<p>Such diffraction patterns and some heavy convolution magic are what ArionFX uses to compute glare on HDR images:</p>

<p><em>Resulting glare in ArionFX</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/012e902dbf.png" width="480" height="320" alt="" /></p>

<p>&ndash;</p>

<p>Now, let‚Äôs focus on what happens to the FT (frequency space) when one does certain operations on the source data (image space). Or, in this exemplification: what happens to the diffraction pattern, when one plays with the rasterized aperture mask.</p>

<p>Note that we‚Äôre speaking of the Discrete Fourier Transform, so sampling (rasterization, pixelization) issues are mostly ignored.</p>

<h3 id="rotation-about-the-center">Rotation about the center</h3>

<p>A rotation of the source buffer about its center doesn‚Äôt change the frequencies present in the data; only their orientation. So a rotation in the source data rotates the FT rotates in the exact same way.</p>

<p>As we will see next, this property holds true regardless of the center of rotation, because the FT is invariant with respect to translations.</p>

<p><em>Rotation about the center</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/a31a55c21f.png" width="600" height="600" alt="" /></p>

<h3 id="translation-with-warp-around">Translation (with warp-around)</h3>

<p>Frequencies arise from the relative position of values in the data field, and not from their absolute position in said field. For this reason, shifting (warp-around included) the source data does not affect the corresponding Fourier Transform in any way.</p>

<p><em>Invariance to translation</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/09db31ab29.png" width="600" height="900" alt="" /></p>

<p>Let‚Äôs recall that the idea behind the FT is that <em>‚Äúany periodic function can be rewritten as a weighted sum of sines and cosines of different frequencies‚Äù</em>. Periodic being the keyword there.</p>

<h3 id="repetition-tiling">Repetition (tiling)</h3>

<p>Tiling the data buffer NxM times (e.g., 2√ó2 in the example below) produces the same FT, but with frequencies ‚Äúexploded‚Äù every NxM cells, canceling out everywhere else.</p>

<p>This is because no new frequencies are introduced, since we are transforming the same source data. However, the source data is NxM times smaller proportional to the data buffer size (i.e., the frequencies become NxM times higher).</p>

<p><em>Exploded frequencies on tiling</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/6ed11eb3b1.png" width="600" height="300" alt="" /></p>

<h3 id="data-scaling">Data scaling</h3>

<p>Normalization and sampling issues aside, scaling the data within the source buffer scales the FT inversely.</p>

<p>This is because encoding smaller data requires higher frequencies, while encoding a larger version of the same data requires lower frequencies.</p>

<p><em>Inverse effect on scaling</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/c7adf5446a.png" width="600" height="1200" alt="" /></p>

<p>In the particular case of glare (e.g., ArionFX) this means that the diffraction pattern becomes blurry if the iris is sampled small. Or, in other words, for a given iris, the sharpest diffraction pattern possible is achieved when the iris is sampled as large as the data buffer itself.</p>

<p>Note, however, that ‚Äúlarge‚Äù here means ‚Äúwith respect to the data buffer‚Äù, being the size of the data buffer irrelevant as we will see next.</p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/29/hosek-wilkie-sky.html">Hosek &amp; Wilkie sky model (2015-03-03)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/29/hosek-wilkie-sky.html" class="u-url"><time class="dt-published" datetime="2022-01-29 16:00:00 &#43;0200">Jan 29, 2022</time></a>

        <div class="e-content">
         	<p><strong>[EDIT] This post was migrated from my blog from 2011‚Ä¶</strong></p>

<p>This is an old comparison between the Preetham and Hosek &amp; Wilkie sky/sun models.</p>

<p><em>Preetham et al. sky model</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/6c9c260561.png" width="600" height="600" alt="" /></p>

<p><em>Hosek &amp; Wilkie sky model</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/70e29da8dd.png" width="600" height="600" alt="" /></p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/29/scrambled-halton.html">Scrambled Halton (2015-03-10)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/29/scrambled-halton.html" class="u-url"><time class="dt-published" datetime="2022-01-29 16:00:00 &#43;0200">Jan 29, 2022</time></a>

        <div class="e-content">
         	<p><strong>[EDIT] This post was migrated from my blog from 2011‚Ä¶</strong></p>

<p>The Halton sequence, which is one of my favourite algorithms ever, can be used for efficient stratified multi-dimensional sampling. Some references:</p>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Van_der_Corput_sequence">Van der Corput sequence</a></li>
<li><a href="https://en.wikipedia.org/wiki/Halton_sequence">Halton sequence</a></li>
</ul>

<p>It is possible to do stratified sampling of hyper-points in the <em>s-dimensional</em> unit hyper-cube by picking one consecutive dimension of the Halton series for each component. A convenient way to do so is to use the first <em>s</em> prime numbers as the basis for each Halton sequence.</p>

<p>It is well-known, however, that while this approach works great for low dimensions, high dimensions often exhibit a great degree of undesired correlation. The following image displays a grid where each cell combines two components of the <em>32-dimensional</em> Halton hyper-cube.</p>

<p><em>Raw 32-dimensional Halton hyper-cube</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/cac06392ac.png" width="600" height="600" alt="" /></p>

<p>One can easily spot how some pairs exhibit an obvious pattern, while others fill their corresponding 2D area very densely. This happens more aggressively for higher dimensions (<em>i.e.,</em> to the right/bottom in the image) and for pairs formed with close components (<em>i.e.,</em> near the diagonal in the image). Click to enlarge!</p>

<p>A successful approach to dissolve this problem without losing the good properties of stratification is to do <em>‚Äúrandom digit scrambling‚Äù</em> (<em>a.k.a.,</em> rds). During the construction of a Halton number, digits in the range <code>[0..base[</code> are combined. Given a <em>Pseudo-Random Permutation</em> of <code>length=base</code>, all that one must do is use <code>PRP(digit)</code> instead of digit directly. This somewhat shuffles Halton pairs in rows and columns in a strong way so the correlation disappears. However, since the PRP is a bijection, the good properties of stratification are generally preserved.</p>

<p>How to build a strong and efficient randomised PRP of an arbitrary length is an interesting subject which details I won‚Äôt get into here.</p>

<p>Here‚Äôs the scrambling strategy in action:</p>

<p><em>Scrambled 32-dimensional Halton hyper-cube</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/2df80353ac.png" width="600" height="600" alt="" /></p>

<p>Now all the blocks in the grid look equally dense. Magic!</p>

<p>As long as one picks good PRPs, it is possible to generate any number of different samplings, all with the same good properties.</p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/29/sobel-operator.html">Sobel operator (2014-09-07)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/29/sobel-operator.html" class="u-url"><time class="dt-published" datetime="2022-01-29 15:56:00 &#43;0200">Jan 29, 2022</time></a>

        <div class="e-content">
         	<p><strong>[EDIT] This post was migrated from my blog from 2011‚Ä¶</strong></p>

<p>The <a href="https://en.wikipedia.org/wiki/Sobel_operator">Sobel operator</a> is a simple way to approximate the gradient of the intensity in an image. This, in visual terms, can be used for <em>edge detection</em>. The purpose of edge detection is to significantly reduce the amount of data in the image, while preserving the structural properties to be used for further image processing.</p>

<p>In practice, the Sobel operator is simply a pair of 3√ó3 (separable) <em>convolution kernels</em>. One highlights the horizontal gradient/edges, and the other one highlights the vertical gradient/edges.</p>

<p><img src="https://www.brashandplucky.com/uploads/2022/628b3579aa.png" width="160" height="60" alt="" /></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/cf022b06bf.png" width="160" height="60" alt="" /></p>

<p>In non-formal terms, and under certain theoretical assumptions, this is conceptually equivalent to computing the partial derivatives of the image with respect to x an y.</p>

<p>For the examples below, I am using as input the same image featured by Wikipedia in the Sobel operator page:</p>

<p><em>Sobel operator</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/b2d2de2218.png" width="600" height="681" alt="" /></p>

<p>This grid presents:</p>

<ol>
<li>The input image (luminance).</li>
<li>The absolute magnitude of the result of the Sobel filter.</li>
<li>The result of the Sobel (x) filter.</li>
<li>The result of the Sobel (y) filter.</li>
<li>Same as (2), but in faux color.</li>
<li>The gradient vectors, normalized and displayed as an RGB-encoded normal map.</li>
</ol>

<p>The 3-tap Sobel convolution kernels have a 1px radius, so they have a very limited edge detection range. This makes the filter quite shaky as soon as the image presents fine details or noise. For this reason, one may want to pre-pass the input image with a subtle Gaussian blur.</p>

<p>This has the effect of diminishing edges in general (as expected), but the resulting gradient images are equivalent, yet much cleaner.</p>

<p>Sobel operator (Gaussian with sigma=2)</p>

<p><img src="https://www.brashandplucky.com/uploads/2022/cce8b82fd4.png" width="600" height="681" alt="" /></p>

<p>The Sobel operator is one of the most fundamental building blocks in feature detection in the field of Computer Vision.</p>

<p>Note that the Sobel operator does not characterize edges or detects features in any way. It simply produces a filtered image where pixels that most likely belong to an area of high gradient (such as an edge) are highlighted.</p>

<p><em>Bonus remark:</em> Sobel filtering is very similar to what a render engine such as <a href="https://maverickrender.com">Maverick</a> does to transform a height map (bump map) into a normal map.</p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/29/the-error-function.html">The Error function (erf) (2014-09-06)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/29/the-error-function.html" class="u-url"><time class="dt-published" datetime="2022-01-29 15:55:00 &#43;0200">Jan 29, 2022</time></a>

        <div class="e-content">
         	

<p><strong>[EDIT] This post was migrated from my blog from 2011‚Ä¶</strong></p>

<p>Here is the 1D Gaussian function:</p>

<p><img src="uploads/2022/0a79850a48.png" width="136" height="31" alt="" /></p>

<p>Put in short, the <a href="https://en.wikipedia.org/wiki/Error_function">Error function</a> is the integral of the Gaussian function from 0 to a certain point x:</p>

<p><img src="uploads/2022/545dcc77e5.png" width="139" height="22" alt="" /></p>

<p>At least, that is the way the formula is presented by Wikipedia and <a href="https://mathworld.wolfram.com/Erf.html">Wolfram|Alpha</a>. But as soon as you try to work with it you find out that in order to really match the above Gaussian function, normalization and axis scaling must be taken care of:</p>

<p><img src="uploads/2022/353905b96a.png" width="159" height="27" alt="" /></p>

<p>The plots below display <code>G(x,sigma)</code> (bell-shaped) in blue, and <code>erf(x,sigma)</code> (S-shaped) in yellow.</p>

<p>A very typical use for <code>G(x,sigma)</code> that I‚Äôve been talking about on this blog lately, is to build convolution kernels for Gaussian blur. An image convolution kernel, for example, is a pixel-centered discretization of a certain underlying function (a Gaussian, in this case). Said discretization splits the x axis in uniform unit-length bins (<em>a.k.a.,</em> taps, or intervals) centered at x=0.</p>

<p>For each bin, this is pretty much the definition of the integral of <code>G(x,sigma)</code> along the bin. That is, the increment of <code>erf(x,sigma)</code> between both end-points of the bin.</p>

<p><em>Discretized 1D Gaussian (sigma=0.5)</em></p>

<p><img src="uploads/2022/7753576e75.png" width="512" height="512" alt="" /></p>

<p><em>Discretized 1D Gaussian (sigma=1.0)</em></p>

<p><img src="uploads/2022/4bef51783b.png" width="512" height="512" alt="" /></p>

<p><em>Discretized 1D Gaussian (sigma=1.5)</em></p>

<p><img src="uploads/2022/6352091d75.png" width="512" height="512" alt="" /></p>

<h3 id="doing-it-wrong">Doing it wrong:</h3>

<p>Most implementations of Gaussian convolution kernels simply evaluate <code>G(x,sigma)</code> at the mid-point of each bin. This is a decent approximation that is also trivial to implement:</p>

<p><img src="uploads/2022/fdd4889b6e.png" width="162" height="20" alt="" /></p>

<p>This value is represented in blue in the above plots.</p>

<h3 id="implementing-erf">Implementing erf:</h3>

<p>While <code>G(x,sigma)</code> has a trivial explicit formulation, <code>erf</code> is an archetypical non-elementary function.</p>

<p>Some development environments provide an <code>erf</code> implementation. But most (the ones I use) don‚Äôt. There are some smart example implementations out there if you Google a bit. Usually they are either numerical approximations, or piece-wise interpolations.</p>

<p>Assuming that one has an <code>erf</code> implementation at his disposal, the correct value for the bin <code>[a..b]</code> is:</p>

<p><img src="uploads/2022/f461644e4a.png" width="232" height="17" alt="" /></p>

<p>This value is represented in red in the above plots.</p>

<h3 id="a-poor-man-s-approximation">A poor-man&rsquo;s approximation:</h3>

<p>If you are feeling lazy, an alternative approximation is to super-sample <code>G(x,sigma)</code> along the bin. The amount of samples can be chosen to be proportional to how small <code>sigma</code> is.</p>

<p>This method is easy to implement. However, it is far less elegant and also less efficient as more evaluation calls are required.</p>

<h3 id="conclusion">Conclusion:</h3>

<p>When discretizing a Gaussian function, as sigma becomes small (close to or smaller than <code>(b-a)</code>), the approximation <code>bin(a,b)</code> (in blue above) deviates significantly from the correct <code>bin'(a,b)</code> (in red above).</p>

<p>So if you are going to Gaussian-blur at radius 1px or smaller, and precision is important, then it is necessary to use <code>erf(x,sigma)</code> or at least super-sample <code>G(x,sigma)</code>.</p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/29/downsampling-and-gaussian.html">Downsampling and Gaussian blur (2014-09-01)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/29/downsampling-and-gaussian.html" class="u-url"><time class="dt-published" datetime="2022-01-29 15:54:00 &#43;0200">Jan 29, 2022</time></a>

        <div class="e-content">
         	

<p><strong>[EDIT] This post was migrated from my blog from 2011‚Ä¶</strong></p>

<p>I talked about several strategies to optimize convolutions in some of my previous posts. I still got to talk about how to approximate a Gaussian blur using a multi-step Box blur in a future post. However, there is yet another good technique to optimize a Gaussian blur that may come handy in some cases.</p>

<p>This post is inspired by a need that I had some days ago: Say that you need to do a 3D Gaussian blur on a potentially humongous 3D data buffer. Working with downsampled data sounds ideal in terms of storage and performance. So that‚Äôs what I am going to talk about here:</p>

<p><em>What happens when downsampled data is used as input for a Gaussian blur?</em></p>

<h2 id="the-idea">The idea:</h2>

<p>Here‚Äôs the 0-centered and un-normalized 1D Gaussian function:</p>

<p><img src="https://www.brashandplucky.com/uploads/2022/0b597462a0.png" width="103" height="26" alt="" /></p>

<p>The <em>sigma</em> parameter in the Gaussian function stretches the bell shape along the x axis. So it is quite straightforward to understand that if one downsamples the input dataset by a scale factor <em>k</em>, then applies a (smaller) Gaussian where <em>sigma‚Äô=s/k</em>, and finally upscales the result by the same scale factor <em>k</em>, the result will approximate a true Gaussian on the original dataset where sigma=s.</p>

<p>In cleaner terms: if one has an input dataset (<em>e.g.,</em> an image) <em>I</em> and wants to have it blurred by a Gaussian where <em>sigma=s</em>:</p>

<ol>
<li><em>I‚Äô&lt;=I</em> downsampled by a certain scale factor <em>k</em>.</li>
<li><em>I‚Äù&lt;=I&rsquo;</em> blurred by a small Gaussian where <em>s‚Äô=s/k</em>.</li>
<li><em>I‚Äù‚Äô&lt;=I&rdquo;</em> upscaled by a scale factor <em>k</em>.</li>
</ol>

<h2 id="how-good-is-this-approximation">How good is this approximation?</h2>

<p>The <a href="https://mathworld.wolfram.com/SamplingTheorem.html">Sampling Theorem</a> states that sampling a signal at (at least) twice its smallest wavelength is enough. Which means that downsampling cuts frequencies above the <em>Nyquist</em> limit (half the sampling rate). In other words: Downsampling means less data to process, but at the expense of introducing an error.</p>

<p>Fortunately, a Gaussian blur is a form of low-pass frequency filter. This means that blurring is quite tolerant to alterations in the high part of the frequency spectrum.</p>

<h2 id="visual-evaluation">Visual evaluation:</h2>

<p>In the examples below I am downsampling with a simple pixel average, and I am upscaling with a simple bilinear filter. The 2x2 grids below compare:</p>

<ol>
<li>Top-left ‚Äì The original image <em>I</em>.</li>
<li>Top-right ‚Äì <em>I</em> downsampled and upscaled by k (note the blocky bilinear filter look).</li>
<li>Bottom-left ‚Äì The resulting image <em>I‚Äù‚Äô</em>.</li>
<li>Bottom-right ‚Äì <em>I</em> blurred by a true Gaussian where sigma=s.</li>
</ol>

<p>In these examples, <em>k=sigma</em> was chosen for simplicity. This means that the small Gaussian uses <em>sigma‚Äô=1</em>.</p>

<p><em>Gaussian blur where sigma=4</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/3fc179f5ba.png" width="600" height="401" alt="" /></p>

<p><em>Gaussian blur where sigma=16</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/c9d9705c2e.png" width="600" height="401" alt="" /></p>

<p><em>Gaussian blur where sigma=64</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/87d800496a.png" width="600" height="401" alt="" /></p>

<h2 id="conclusion">Conclusion:</h2>

<p>As shown, the approximation (bottom-left vs. bottom-right) is pretty good.</p>

<p>The gain in speed depends on multiple implementation factors. However, as I explained above, this post was inspired by a need to cope with a cubic memory storage problem when doing Gaussian blurs on a 3D buffer. Working with a heavily downsampled buffer clearly helps in that sense. And it is needless to say that decreasing the amount of data to process by <em>k^3</em> also brings a dramatic speed boost, making it possible to use tiny separable convolutions along the 3 (downsampled) axes.</p>

<p>Note that one might pick any downsampling scale factor <em>k&gt;=1</em>. The higher the value of <em>k</em>, the higher the approximation error and the smaller and faster the convolution.</p>

<p>The choice <em>k=sigma</em> offers a good trade-off between approximation error and speed gain as shown above.</p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/29/diaphragm-and-fstop.html">Diaphragm and f-stop (2014-08-17)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/29/diaphragm-and-fstop.html" class="u-url"><time class="dt-published" datetime="2022-01-29 15:51:10 &#43;0200">Jan 29, 2022</time></a>

        <div class="e-content">
         	<p><strong>[EDIT] This post was migrated from my blog from 2011‚Ä¶</strong></p>

<p>This is just another image taken from the Maverick Unit Testing system. The chart displays different polygonal diaphragms at different f-stop values. Doubling the f-stop number, halves the surface light can pass through.</p>

<p><em>Polygonal diaphragms and f-stop</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/f558614798.png" width="544" height="512" alt="" /></p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/29/glare-patterns.html">Glare patterns (2014-08-14)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/29/glare-patterns.html" class="u-url"><time class="dt-published" datetime="2022-01-29 15:49:00 &#43;0200">Jan 29, 2022</time></a>

        <div class="e-content">
         	<p><strong>[EDIT] This post was migrated from my blog from 2011‚Ä¶</strong></p>

<p>Glare in photography is due to <a href="https://en.wikipedia.org/wiki/Fraunhofer_diffraction">Fraunhofer diffraction</a> as light from distant objects passes through the camera diaphragm.</p>

<p>There is a magical connection between Fraunhofer diffraction (physics) and the Fourier Transform (math). As a matter of fact, the intensity of the Fraunhofer diffraction pattern of a certain aperture is given by the squared modulus of the Fourier Transform of said aperture.</p>

<p>Assuming a clean and unobstacled camera, the aperture is the diaphragm shape. Here you have the diffraction patterns that correspond to some basic straight-blade (polygonal) diaphragms.</p>

<p><em>Glare patterns</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/d174a5ac84.png" width="600" height="225" alt="" /></p>

<p>Interestingly, the Fourier Transform produces one infinite decaying streak perpendicular to each polygon edge. When the number of edges is even, the streaks overlap in pairs. That is why an hexagonal diaphragm produces 6 streaks, and an heptagonal diaphragm produces 14.</p>

<p>The leftmost pattern happens to be the <a href="https://en.wikipedia.org/wiki/Airy_disk">Airy disk</a>. The Airy disk is a limit case where the number of polygon edges/streaks is infinite.</p>

<p>The examples above were generated at 256x256. The visual definition of the pattern naturally depends on the resolution of the buffers involved in the computation of the Fourier Transform. However, note that the FT has an infinite range. This means that for ideal polygonal shapes, the streaks are infinitely long.</p>

<p>In the practical case, buffers are far from infinite, and you hit one property of the Fourier Transform that is often nothing but an annoyance: the FT is cyclic. The image below depicts what happens when one pumps up the intensity of one of the glare patterns obtained above: the (infinite) streaks, which warp-around the (finite) FT buffer, become evident.</p>

<p><em>Cyclic glare pattern</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/070390a6aa.png" width="600" height="285" alt="" /></p>

<p><em>Bonus:</em> Here‚Äôs some real-life glare I screengrabbed this evening at the European Athletics Championships.</p>

<p><em>Real-life glare</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/475a218b49.png" width="512" height="300" alt="" /></p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/29/my-latest-running.html">My latest running shoes (2014-08-07)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/29/my-latest-running.html" class="u-url"><time class="dt-published" datetime="2022-01-29 15:47:00 &#43;0200">Jan 29, 2022</time></a>

        <div class="e-content">
         	<p><strong>[EDIT] This post was migrated from my blog from 2011‚Ä¶</strong></p>

<p>I have run my latest 7000 km or so on Nike Lunaracer+ (v1 and v3) shoes. This week I started my last pair. I will have to re-stock soon.</p>

<p><em>My latest 7000 km</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/bce75368a2.jpg" width="600" height="384" alt="" /></p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/29/fast-convolutions-iii.html">Fast convolutions (III) (2014-07-19)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/29/fast-convolutions-iii.html" class="u-url"><time class="dt-published" datetime="2022-01-29 15:44:00 &#43;0200">Jan 29, 2022</time></a>

        <div class="e-content">
         	<p><strong>[EDIT] This post was migrated from my blog from 2011‚Ä¶</strong></p>

<p>Some more remarks about the performance of the convolution methods described so far. I will be leaving the brute-force algorithm out for obvious reasons.</p>

<p>The plot below represents input size (in pixels) in the x axis, and convolution time (in seconds) in the y axis. So, if you go to <em>x=4096</em> that means <em>‚Äúa convolution of a 4096√ó4096 image by a 4096√ó4096 kernel‚Äù</em>.</p>

<p><em>Even competition between FFT-based vs. separable convolution methods</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/e0fc16f520.png" width="516" height="516" alt="" /></p>

<p>Two conclusions can be made from the above plot, which confirm what was explained in my previous post:</p>

<ol>
<li>For large kernels (as large as the image itself) the separable convolution method is <em>O(n^3)</em> and times get to absurd levels very quickly. If you are dealing with large generic images/kernels, the FFT-based method is the way to go.</li>
<li>The FFT-based method uses the Fast Fourier Transform, which is <em>O(n^2¬∑log(n))</em> thanks to some decomposition technique that requires the size of the input data to be (padded to) a power-of-2. For this reason, it takes the same amount of time to do a convolution on a <em>257√ó257</em> image/kernel than on a <em>512√ó512</em> image/kernel, because both cases operate on <em>512√ó512</em> buffers after all. This is why the graph for the FFT method is stepped. When x crosses a power-of-2, the running time goes up all of a sudden and stays stable until the next power-of-2.</li>
</ol>

<p>The plot was generated with my current implementation of both convolution methods in MK_api. My FFT uses the Cooley-Tukey algorithm, and everything (i.e., FFT, IFFT, point-wise products, and 1D separable convolutions) makes use of multi-threading. There‚Äôs always room for improvement, but the running times seem pretty decent, as we‚Äôre speaking of <em>&lt;2s</em> for images up to <em>4096√ó4096</em> in a 16-thread CPU. An implementation in CUDA would be (orders of magnitude) faster, though. üòõ</p>

<p><strong>[EDIT] It&rsquo;s been 8 years since this post (2014..2022). Now we use the cuFFT implementation in Maverick, which is blazingly fast.</strong></p>

<p><em>Separable convolution with a fixed 11√ó11 kernel (in orange)</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/e8ec462e51.png" width="516" height="516" alt="" /></p>

<p>A couple more remarks:</p>

<ol>
<li>The graph of the FFT-based method wouldn‚Äôt change if smaller kernels were used, as the algorithm requires the kernel to be padded to the size of the image. However, the graph of the separable method becomes much less steep when very small kernels are used:</li>
<li>The running time of the FFT/IFFT is not exactly a trivial subject. Speed in FFT/IFFT algorithms depends not only on the size of the data, but also on the data itself. While generating the above plots, I came across some anomalies in the time measurements. Some kernels or some images produced faster or slower results. Some combinations would even produce non-flat steps in the staircase-looking graph. That‚Äôs normal, but worth mentioning.</li>
</ol>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/29/fast-convolutions-ii.html">Fast convolutions (II) (2014-07-18)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/29/fast-convolutions-ii.html" class="u-url"><time class="dt-published" datetime="2022-01-29 15:43:00 &#43;0200">Jan 29, 2022</time></a>

        <div class="e-content">
         	

<p><strong>[EDIT] This post was migrated from my blog from 2011‚Ä¶</strong></p>

<p>I will analyze the algorithmic complexity of the convolution algorithms described in my previous posts.</p>

<p>To make things simpler, let‚Äôs assume that the dimensions of the image are &gt;= the dimensions of the convolution kernel, and that both are square, with dimensions <em>S¬∑S</em> and <em>s¬∑s</em>, respectively.</p>

<h2 id="naive-algorithm-o-n-4">Naive algorithm - O(n^4)</h2>

<p><em>&ldquo;wxh operations for each of the W¬∑H image pixels‚Äù.</em></p>

<p><em>i.e.,</em> <em>S¬∑S¬∑s¬∑s</em> operations. This is quadratic with a heavy constant for tiny kernels, but quickly becomes quartic for medium-to-large kernels.</p>

<p>The auxiliary buffer can be identical in size and bit-depth to the original image. So the memory usage factor is 2x.</p>

<h2 id="separable-convolution-o-n-3">Separable convolution - O(n^3)</h2>

<p><em>&ldquo;One 1D convolution for each row + One 1D convolution for each column‚Äù.</em></p>

<p><em>i.e.,</em> <em>2¬∑S¬∑S¬∑s</em> operations. This is quadratic with a bad constant for small kernels, but becomes cubic for large kernels.</p>

<p>Remarkably, the total running time depends on the dimensions of the image -and- the dimensions of the kernel.</p>

<p>Again, the auxiliary buffer can be identical in size and bit-depth to the original image. So the memory usage factor is 2x.</p>

<h2 id="convolution-theorem-o-n-2-log-n">Convolution theorem - O(n^2¬∑log(n))</h2>

<p><em>‚ÄúTwo FFTs + One point-wise product + One IFFT‚Äù.</em></p>

<p>Let‚Äôs call <em>S‚Äô</em> to the closest power-of-2 such that <em>S‚Äô&gt;=S</em>. Then a proper implementation of the FFT/IFFT does (approx.) <em>2¬∑S‚Äô¬∑S‚Äô¬∑log(S`)</em> operations, while the point-wise product does <em>S‚Äô¬∑S‚Äô</em> operations. This makes the algorithm <em>O(S‚Äô¬∑S‚Äô¬∑log(S‚Äô))</em> with some heavy (quadratic) overhead due to the memory copying, padding, and the point-wise product.</p>

<p>Remarkably, the total running time is independent of the size of the kernel.</p>

<p>This algorithm is quite memory hungry, though, because two <em>S‚Äô¬∑S‚Äô</em> complex-number buffers are required. This means two floating-point numbers per entry (i.e., the real/imaginary coefficients). The algorithm starts by copying the image/kernel to the real part of the corresponding complex-number buffer, leaving the imaginary coefficient and the surface excess filled with zeroes. Then the FFTs/product/IFFT happen in-place.</p>

<p>So the auxiliary memory required is <em>4¬∑S‚Äô¬∑S‚Äô</em> floating-point numbers.</p>

<p>In the worst case where <em>S</em> is a power-of-2-plus-1, <em>S‚Äô</em> gets nearly twice as large as <em>S</em>. If the original image is 8-bit and we are using single-precision floating-point math for the FFT/IFFT, this means a memory usage factor of 64x. In the case of an HDR (single-precision floating-point) grayscale image, we are speaking of a worst case scenario of 16x. In average, however, the memory usage factor is around 8x. If <em>S</em> is a power-of-2, then the memory usage factor goes down to 4x.</p>

<p><em>Heavy glare using the FFT-based method in an HDR image by Paul Debevec</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/b55d5885bf.gif" width="341" height="512" alt="" /></p>

<p>This image with heavy glare has been output with some ArionFX-related experimental tonemapping code I am working on these days.</p>

<h3 id="conclusions">Conclusions:</h3>

<p>Assuming that we are only interested in sheer performance:</p>

<ol>
<li>The FFT-based method is (by far) the fastest for large images/kernels. Interestingly, the algorithm is not affected by the size of the kernel, which can be as large as the (padded) image itself without a penalty.</li>
<li>The FFT-based method becomes even faster if the same kernel is applied multiple times. The kernel FFT can be calculated just once, and then be re-used.</li>
<li>Due to the heavy setup overhead in the FFT-based method, the separable method can be faster for small (separable) kernels where <em>s</em> is in the range of <em>log(S‚Äô)</em>.</li>
</ol>

<p>Last, but certainly not least, <strong>there is a much faster and more light-weight algorithm for the special case of Box/Gaussian Blur</strong>. I will talk about this in a separate blog entry.</p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/28/fast-convolutions-i.html">Fast convolutions (I) (2014-07-18)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/28/fast-convolutions-i.html" class="u-url"><time class="dt-published" datetime="2022-01-28 03:55:00 &#43;0200">Jan 28, 2022</time></a>

        <div class="e-content">
         	

<p><strong>[EDIT] This post was migrated from my blog from 2011‚Ä¶</strong></p>

<p>In my <a href="https://www.brashandplucky.com/pointspread-functions-convolutions.html">previous post</a> it was stated that the convolution of a WxH image with a wxh kernel is a new WxH image where each pixel is the sum of wxh products obtained as the central pixel of the kernel slides across each of the pixels in the original image. This double-double loop leads to an impractical <code>O(n^4)</code> algorithm complexity.</p>

<p>Fortunately, we can do better, but the key here is not in optimizing the code, but in making use of some mathematical weaponry. Let‚Äôs analyze the options that we have:</p>

<ol>
<li>Naive implementation.</li>
<li>Separable convolution kernels.</li>
<li>The convolution theorem.</li>
<li>Can we do EVEN better?</li>
</ol>

<h2 id="naive-implementation">Naive implementation.</h2>

<p><em>Pros:</em></p>

<ul>
<li>Trivial implementation in just a few lines of code.</li>
<li>Works for any input size, and for any type of kernel.</li>
<li>Trivial clamping at the boundaries.</li>
<li>Allows for multi-threading.</li>
</ul>

<p><em>Cons:</em></p>

<ul>
<li>Embarrassingly inefficient: <code>O(n^4)</code>.</li>
<li>Requires an auxiliary WxH buffer.</li>
<li>By default, the output of the operation is returned in the auxiliary buffer (not <em>in-place</em>).</li>
<li>Not very cache friendly due to the constant jumps across rows.
‚Äì Applying the same kernel multiple times has the same cost, every time.</li>
</ul>

<p><em>When should I use this method?</em></p>

<ul>
<li>Never, unless the input data is tiny and clean code is more important than sheer performance.</li>
</ul>

<h2 id="separable-convolution-kernels">Separable convolution kernels.</h2>

<p>A separable convolution kernel is one that can be broken into two 1D (vertical and horizontal) projections. For these projections the (matrix) product of the 1xh vertical kernel by the wx1 horizontal kernel must restore the original wxh 2D kernel.</p>

<p><em>1D vertical and horizontal Gaussian convolution</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/4171094912.png" width="600" height="402" alt="" /></p>

<p>Conveniently enough, the most usual convolution kernels (<em>e.g.,</em> Gaussian blur, box blur, ‚Ä¶) happen to be separable.</p>

<p>The convolution of an image by a separable convolution kernel becomes the following:</p>

<ol>
<li>Convolute the rows of the original image with the horizontal kernel projection.</li>
<li>Convolute the columns of the resulting image with the vertical kernel projection.</li>
</ol>

<p>Note: These two steps are commutative.</p>

<p><em>2-step separable vs. brute-force 2D Gaussian convolution</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/35a6c714ba.png" width="600" height="608" alt="" /></p>

<p><em>Pros:</em></p>

<ul>
<li>More efficient than the naive implementation: <code>O(n^3)</code>.</li>
<li>Trivial implementation in just a few lines of code.</li>
<li>Trivial clamping at the boundaries.</li>
<li>Works for any input size.</li>
<li>Since this is a two-step process, the convolution can be returned <em>in-place</em>.</li>
<li>Cache-friendly.</li>
<li>Allows for multi-threading.</li>
</ul>

<p><em>Cons:</em></p>

<ul>
<li>Only works with separable kernels.</li>
<li>Needs an auxiliary WxH buffer.</li>
<li>Applying the same kernel multiple times has the same cost, every time.</li>
</ul>

<p><em>When should I use this method?</em></p>

<ul>
<li>We do not use this method anywhere in Maverick&rsquo;s API. You will understand why soon.</li>
</ul>

<h2 id="the-convolution-theorem">The convolution theorem.</h2>

<p>‚ÄúThe <a href="https://en.wikipedia.org/wiki/Convolution_theorem">convolution</a> in the spatial domain is equivalent to a point-wise product in the frequency domain, and vice-versa.‚Äù</p>

<p>This method relies on the (Fast) <a href="https://en.wikipedia.org/wiki/Fourier_transform">Fourier Transform</a>, which is one of the most beautiful mathematical constructs, ever. Seriously!</p>

<p>The convolution of an image by a generic kernel becomes the following:</p>

<ol>
<li>Compute the Fourier Transform of the image.</li>
<li>Compute the Fourier Transform of the kernel.</li>
<li>Multiply both Fourier Transforms, point-wise.</li>
<li>Compute the Inverse Fourier Transform of the result.</li>
</ol>

<p><em>Brute-force 2D Gaussian vs. the convolution theorem</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/71f4742163.png" width="600" height="609" alt="" /></p>

<p><em>Magic</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/9fd4b3d82e.gif" width="350" height="196" alt="" /></p>

<p><em>Pros:</em></p>

<ul>
<li>Even more efficient: <code>O(n^2¬∑log(n))</code>.</li>
<li>Works with any convolution kernel, separable or not.</li>
<li>Should the kernel be applied multiple times, the FFT of the kernel can be computed just once, and then be re-used.</li>
<li>The FFT/IFFT and the convolution product are cache-friendly.</li>
<li>The FFT/IFFT and the convolution product allow for multi-threading.</li>
</ul>

<p><em>Cons:</em></p>

<ul>
<li>Definitely not easy to implement, unless you already own an FFT module that suits your needs.</li>
<li>The FFT operates on buffers with power-of-2 dimensions. This means that the input image (and the kernel) must be padded with zeroes to a larger size (i.e., extra setup time + memory).</li>
<li>Both the image and the kernel are transformed, which requires two auxiliary buffers instead of one.</li>
<li>Each FFT produces complex-number values, which doubles the memory usage of each auxiliary buffer.</li>
<li>The dynamic range of the FFT values is generally wilder than that of the original image. This requires a careful implementation, and the use of floating-point math regardless of the bit-depth and range of the input image.</li>
<li>This method doesn‚Äôt do any clamping at the boundaries of the image, producing a very annoying warp-around effect that may need special handling (e.g., more padding).</li>
</ul>

<p><em>When should I use this method?</em></p>

<ul>
<li>Every time that a large generic convolution kernel (i.e., not a simple blur) is involved.</li>
<li>The most obvious examples I can think of in Maverick&rsquo;s are Glare &amp; Bloom.</li>
</ul>

<h2 id="can-we-do-even-better">Can we do EVEN better?</h2>

<p>Oh yes. We can do much better, at least in the very particular case of blur. I will talk about this in detail in a dedicated blog entry, at some point.</p>

<p><strong>Some implementation remarks:</strong></p>

<p>All the algorithms presented above allow for <strong>multi-threading</strong>. Naturally, MT does not change the algorithm complexity, since the maximum number of threads is fixed, but you can get very decent speeds in practical cases if you combine sleek code with proper multi-threading. In the separable case (2), MT must be used twice. First for the rows, and then for the cols. In the FFT case (3), the FFT itself can be multi-threaded (in a rows/cols fashion as well). The huge point-wise product in frequency space can be MT‚Äôed too.</p>

<p>Since convolutions are usually applied on very large images, writing <strong>cache-friendly code</strong> can make a big difference. Assuming that the memory layout of your image/kernel is per rows, make sure to arrange your loops so memory accesses are as consecutive as possible. This is immediate for the loops that do a 1D convolution on each row. However, for the loops that do a 1D convolution on each column, it may help to use a local cache to transpose a column to a row back and forth.</p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/17/pointspread-functions-convolutions.html">Point-Spread Functions &amp; Convolutions (2014-07-14)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/17/pointspread-functions-convolutions.html" class="u-url"><time class="dt-published" datetime="2022-01-17 04:06:00 &#43;0200">Jan 17, 2022</time></a>

        <div class="e-content">
         	<p><strong>[EDIT] This post was migrated from my blog from 2011&hellip;</strong></p>

<p>One might explain what a <a href="https://en.wikipedia.org/wiki/Convolution">convolution</a> is in many ways. However, in the field of image processing, there is an informal and very intuitive way to understand convolutions through the concept of <a href="https://en.wikipedia.org/wiki/Point_spread_function">Point-Spread Functions</a> and their inverses.</p>

<p>A PSF is an arbitrary description of the way in which a point spreads its energy around itself in 2D space.</p>

<p><em>Classic PSFs: 1D box, 2D box, 1D Gaussian, 2D Gaussian</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/abbfbd24d9.png" width="166" height="320" alt="" /></p>

<p>Although this is not a mandatory requirement, the <em>integral</em> of a PSF usually equals 1, so no energy is gained or lost in the process. The above image does not match this requirement for the sake of visualization; the PSFs on the right column have been un-normalized for better visibility. On the other hand, the range of a PSF (how far away from the source point energy is allowed to reach) can be infinite. However, in most practical uses the range is finite, and usually as short as possible.</p>

<p>So, a <code>PSF(x,y)</code> is a function <code>f:R^2-&gt;R</code> or, in the case of images, a finite/discrete real-value 2D matrix. For example, <code>PSF(x,y)=0.2</code> means that the point <code>P=(a,b)</code> sends 20% of its energy to point <code>Q=(a+x,b+y)</code>.</p>

<p>If we apply the above PSFs to all the pixels in an image, this is what we get:</p>

<p><em>Classic PSFs applied to an image</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/12fa4bf752.png" width="243" height="320" alt="" /></p>

<p><em>WARNING: Do not confuse this with a convolution. We‚Äôre not there yet.</em></p>

<p>The inverse of a PSF (let‚Äôs use the term IPSF for now) is a description of what amount of energy a point receives from the points around itself in 2D space.</p>

<p>So, an <code>IPSF(x,y)</code> is also a function <code>f:R^2-&gt;R</code> or, in the case of images, a finite/discrete real-value 2D matrix. For example, <code>IPSF(x,y)=0.2</code> means that the point <code>Q=(a,b)</code> receives 20% of the energy from point <code>P=(a+x,b+y)</code>.</p>

<p>From here follows that a PSF and the corresponding IPSF are radially symmetric:</p>

<p><code>IPSF(-x,-y) = PSF(x,y)</code></p>

<p>If <code>P=(a,b)</code> spreads energy to <code>Q=(a+x,b+y)</code>, then <code>Q=(a‚Äô,b‚Äô)</code> gathers energy from <code>P=(a‚Äô-x,b‚Äô-y)</code>.</p>

<p>Finally: <strong>a convolution is the result of applying the same IPSF to all the pixels of an image</strong>. Note that IPSF matrices are more commonly known as <em>convolution kernels</em>, or <em>filter kernels</em>.</p>

<p>Conveniently enough, the PSFs displayed above are all radially symmetric with respect to themselves. As a matter of fact, it is true to most popular convolution kernels (e.g., 1D/2D box blur, 1D/2D Gaussian blur, ‚Ä¶) that the PSF and the IPSF are identical. This makes the process of spreading/gathering energy equivalent in the cases presented above, but this is not true to other (more exotic) kernels.</p>

<p>In the case of image convolutions, kernels are usually square matrices of dimensions DxD, where <code>D=(R+1+R)</code> and R is generally known as the radius of the kernel. This way, kernels have a central pixel. For instance, a kernel of R=3 (where each pixel is affected by neighbors never farther than 3px away) would be a 7x7 matrix.</p>

<p>The convolution is a fundamental operation in Digital Image Processing, and most image filters (e.g., Gaussian Blur in Photoshop) are based on convolutions in one way or another.</p>

<p><strong>Naive algorithm:</strong> A convolution is an operation that takes two discrete real-value matrices (<em>i.e.,</em> a luminance image and a convolution kernel) and makes the center of the kernel slide along each pixel in the image. At each pixel, the kernel is multiplied point-wise with all the pixels it covers, and the sum of these products is used to replace the original pixel value. Since this operation modifies pixels on the go, an auxiliary buffer is necessary.</p>

<p>Let‚Äôs assume that the resolution of the image is WxH pixels, and the convolution kernel is a matrix of dimensions wxh. The convolution needs to run through WxH pixels and at each pixel, it must perform and add wxh products. This is as slow as <code>O(n^4)</code> = Terrible.</p>

<p>As a matter of fact, the convolution of even a small kernel with a large image can take an eternity (literally) to compute using this naive solution. Fortunately, there is some mathematical trickery that we can take advantage of. More on fast convolutions in a future post.</p>

<p><em>Bonus remark:</em> A particularly nice example of PSF is glare, which comes from the <em>Fraunhoffer diffraction</em> of the camera/eye aperture. Below you can see what happens when a glare PSF is applied to an HDR image. The actual implementation convolutes the IPSF (the radial-symmetric of the glare PSF) with the source HDR image.</p>

<p><em>Glare applied to an Arion render</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/d8b32e04d4.gif" width="600" height="355" alt="" /></p>

<p><em>Typical glare PSF for a 6-blade iris</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/42dd145d06.png" width="256" height="256" alt="" /></p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/16/unbiased-spanningtree-generation.html">Unbiased spanning-tree generation</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/16/unbiased-spanningtree-generation.html" class="u-url"><time class="dt-published" datetime="2022-01-16 17:16:00 &#43;0200">Jan 16, 2022</time></a>

        <div class="e-content">
         	<p>Recently I&rsquo;ve done some micro-tests with spanning-trees in my spare time inspired by some talks I had with my good friend ditiem.</p>

<p>The video below is my implementation of <a href="https://en.wikipedia.org/wiki/Maze_generation_algorithm">Wilson&rsquo;s algorithm</a>.</p>

<p>Spanning-trees can be visualized as classic mazes, which are always pretty to look at (bonus: rainbow floodfill). But let&rsquo;s forget about the maze itself. To me the majestuous beauty of this algorithm lies in the fact that it is <em>fully unbiased</em>:</p>

<ul>
<li>If the random numbers involved are uniformly distributed, it generates an also <em>uniformly distributed random sample</em> in the <em>space of all possible 2D-filling spanning-trees</em>.</li>
<li><em>i.e.,</em> if the algorithm is called an infinite amount of times, <em>all</em> possible such mazes will be generated with <em>equal likelihood</em>.</li>
</ul>

<p><strong>Unbiasedness</strong> for the win.</p>

<p>Some interesting remarks could be made about how to optimize the generation time stochastically. Let&rsquo;s save that discussion for another time&hellip;</p>

<p><a href="https://www.youtube.com/watch?v=uaD1pkrS1wY">Watch on Youtube</a></p>

<video controls="controls" playsinline="playsinline" src="https://www.brashandplucky.com/uploads/2022/ed291d75cb.mp4" width="520" height="520" poster="https://www.brashandplucky.com/uploads/2022/5ca96a4051.png" preload="none"></video>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/16/circular-and-radial.html">Circular &amp; radial blur (2014-07-14)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/16/circular-and-radial.html" class="u-url"><time class="dt-published" datetime="2022-01-16 16:56:00 &#43;0200">Jan 16, 2022</time></a>

        <div class="e-content">
         	<p><strong>[EDIT] This post was migrated from my blog from 2011&hellip;</strong></p>

<p>Circular and radial blur can be implemented in different ways. The method I am going to describe here is reasonably efficient, provided that there is a hyper-fast 1D box-based blur routine at one‚Äôs disposal (more on that in a future post). The algorithm is quite straightforward to implement, and also has the beautiful property of being able to do both circular and radial blur at the same time.</p>

<p>I will work on grayscale images here, although as usual the process can by extended to color images by performing the same operations on the three R, G, and B channels.</p>

<p>The key to circular/radial blur is to not work on the image space directly, but on a dual space, where cartesian co-ordinates are transformed to polar co-ordinates around the central pixel. Like this:</p>

<p><em>Cartesian-to-polar transform</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/2224df4a0d.png" width="600" height="110" alt="" /></p>

<p>Each column in the transformed image is one of the ‚Äòspokes‚Äô that go from the center to one of the pixels at the perimeter in the original image. The length of the largest spoke is half a diagonal, while the perimeter of a WxH image has <code>2¬∑(W+H-2)</code> pixels. So the transformed image is a buffer of dimensions <code>ceil(sqrt(W^2+H^2)/2)</code> and <code>2¬∑(W+H-2)</code>.</p>

<p>We also need an inverse transform that restores the original image from its polar form.</p>

<p>Note that, for better results, the transform and also its inverse must do proper filtering. Since the spokes are diagonals that do not follow the arrangement of the pixels in the original image, the process of transforming and un-transforming is not exactly reciprocal. <em>i.e.,</em> un-transforming the transformed image does not restore the original image identically. In simpler words: this process adds some little blur due to filtering. However, this is ok, because we‚Äôre aiming at circular/radial blur after all.</p>

<p>Below are the schematics of the type of filtering I am using in Maverick&rsquo;s API. When I sample a pixel centered at <code>(xm,ym)</code> along a spoke, I integrate the original image, constrained to a 1x1 square area. This integration simply takes the (up to) 4 overlapped pixels, and weighs each of them by the corresponding surface overlapping factor:</p>

<p><em>Sample 1x1 px area</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/85af42db00.png" width="461" height="322" alt="" /></p>

<p>Note also that the inverse transform must ‚Äòundo‚Äô the filtering, by splatting contributions to the final image using the same surface overlapping factors.</p>

<p>‚Ä¶and here comes the interesting part.</p>

<ul>
<li>If we 1D-blur the rows in the polar-space image, and then apply the inverse transform, we get a circular blur of the original image.</li>
<li>If we 1D-blur the columns in the polar-space image, and then apply the inverse transform, we get a radial blur of the original image.</li>
</ul>

<p>A fast box-based 1D blur implementation can run in O(n), regardless of the radius of the blur. Let‚Äôs assume a square image of side S. The size of the transformed image is <code>2¬∑(S+S-2)¬∑sqrt(2)¬∑S/2</code>, which means a quadratic complexity, or linear with respect to the number of pixels. The algorithm is made of fairly simple arithmetic operations, and allows for multi-threading.</p>

<p>Here you can take a look at a couple of filtering examples taken from Maverick&rsquo;s Unit Testing System:</p>

<p><em>Circular blur</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/783f3b179f.gif" width="600" height="337" alt="" /></p>

<p><em>Radial blur</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/f74e2ef315.gif" width="600" height="337" alt="" /></p>

<p>Some bonus remarks:</p>

<ul>
<li>If the amount of blur becomes progressively small as you approach the center, radial blur becomes lens blur.</li>
<li>If the amount of blur used in radial blur is different for each color component, you get chromatic aberration.</li>
<li>If you work with spectral colors, instead of RGB, chromatic aberration looks great even when the blur stretches colors along long streaks.</li>
</ul>

<p><em>Lens blur &amp; heavy chromatic aberration</em></p>

<p><img src="https://www.brashandplucky.com/uploads/2022/6c6105cdb8.gif" width="600" height="337" alt="" /></p>

<p>Some more final remarks:</p>

<ul>
<li>In general, blur operations are clamped to the boundaries of the buffer they operate on. However, in the case of circular blur, one must warp-around from the first to the last spoke.</li>
<li>It is not really necessary to create the transformed polar image, which is (much) larger than the original. One can feed the 1D blur with transformed pixels directly, and save some memory. Doing so doesn‚Äôt cause a performance penalty, because the algorithm runs through each spoke only once.</li>
</ul>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/15/randomwalk-sss.html">Random-walk SSS</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/15/randomwalk-sss.html" class="u-url"><time class="dt-published" datetime="2022-01-15 01:10:00 &#43;0200">Jan 15, 2022</time></a>

        <div class="e-content">
         	<p>Arion, predecesor of Maverick Render, was already doing &ldquo;random-walk&rdquo; volume and SSS rendering long before the term random-walk even became trendy.</p>

<p>This is a graph plotted by some simulation code I prototyped way back during the R&amp;D phase (circa 2014). Each wavelength (simplified to RGB in the plot) traverses the media with different stochastic statistics.</p>

<p><img src="https://www.brashandplucky.com/uploads/2022/a0dd1496bf.jpg" width="600" height="450" alt="" /></p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/14/legendre-polynomials-because.html">Legendre polynomials</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/14/legendre-polynomials-because.html" class="u-url"><time class="dt-published" datetime="2022-01-14 23:39:00 &#43;0200">Jan 14, 2022</time></a>

        <div class="e-content">
         	<p><a href="https://en.wikipedia.org/wiki/Legendre_polynomials">Legendre polynomials</a>. Because&hellip; Why not?</p>

<p><img src="https://www.brashandplucky.com/uploads/2022/412a9abc3b.png" width="256" height="256" alt="" /></p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/14/215738.html">Anatomy of a PE (2012-10-30)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/14/215738.html" class="u-url"><time class="dt-published" datetime="2022-01-14 22:57:00 &#43;0200">Jan 14, 2022</time></a>

        <div class="e-content">
         	

<p><strong>[EDIT] This post was migrated from my blog from 2011&hellip;</strong></p>

<h2 id="preamble">Preamble</h2>

<p>Executables (EXE/DLL) in Microsoft Windows make use of a format called PE (<em>Portable Executable</em>).</p>

<p>A PE image typically lies in the hard drive as a <em>.exe</em> or <em>.dll</em> file, and is loaded by the <em>Windows Loader</em> into the RAM of the system when a process is created from that file (<em>e.g.</em>, by double-clicking the <em>.exe</em>). So, basically, we have two different states:</p>

<ul>
<li><em>Physical</em> PE image file.</li>
<li><em>Loaded</em> PE image (running process).</li>
</ul>

<h2 id="layout">Layout</h2>

<p>The layout of a PE image contains the following elements:</p>

<ul>
<li>A header, glued at the first byte of the file.</li>
<li>A list of consecutive sections.</li>
<li>An optional chunk of trailing (unused) bytes.</li>
</ul>

<p>These elements are concatenated, and there may or may not be padding space between them. This padding space, if present, is usually filled with <code>0x00</code> bytes.</p>

<p>It is possible to add trailing bytes to a PE image. Actually, those files will simply lie there doing nothing. However, some types of processes such as package installers can use the trailing area to add some payload that the process will use (<em>e.g.,</em> decrypt, uncompress, ‚Ä¶) at some point.</p>

<h2 id="the-pe-header">The PE Header</h2>

<p>The PE header contains a wealth of information, structured in a fixed way.</p>

<p>Among the many details about the PE that you can gather from the header, there‚Äôs the <em>list of sections</em>. The list of sections contains the name, position, and size of each section in the PE, both in physical file format, and when loaded in memory as a process.</p>

<p>Many other things are described by the header, such as the address of the <em>Entry Point</em> (the instruction where code execution must start), and the address of some <em>data directories</em>. It is in these data directories where you can find the list of DLLs the PE depends on, the list of functions exported by the PE, etc‚Ä¶</p>

<p>The PE Header is usually <code>0x0400</code> (1024) bytes long. The data structures contained in it are defined in <code>winnt.h</code>, and they are always the same (so you can assume offsets and such). One must pay attention, though, to the fact that depending on whether the process is 32-bit or 64-bit, some pieces of the header will be PE32 or PE64. One can tell whether the process is 32-bit or 64-bit by checking the header flags (which are found at a location which is common to PE32 and PE64 headers).</p>

<h2 id="rvas-and-vas">RVAs and VAs</h2>

<p>In general, the addresses found in the PE header are given as RVAs (<em>Relative Virtual Addresses</em>). An RVA is an offset relative to the first byte of the PE image. Assuming that you know the location in memory of the first byte of the PE image (the image base pointer), then the relationship between a VA (<em>Virtual Address</em>) and its corresponding RVA is given by:</p>

<p><code>VA = ( base + RVA )</code></p>

<p><code>RVA = ( VA - base )</code></p>

<p>If the PE is a physical file, then the base pointer is simply the start of the file. However, if the PE has been loaded as a process, then the base address can be found in several ways that should (in theory) match:</p>

<ul>
<li>The value returned by <code>GetModuleHandle(0)</code> is, in fact, the base pointer.</li>
<li>The <code>HINSTANCE</code> received by <code>WinMain</code> is, in fact, the base pointer.</li>
<li>The Windows Loader stores the base pointer at the PE header on load, in the <code>BaseOfImage</code> field.</li>
</ul>

<p>The PE header is glued at this location in memory. So, in run-time, one can use this knowledge to do PE-related operations such as leap-frogging through the PE sections. A typical anti-cracking use is to run a CRC32 on the code section in order to display a <em>badboy</em> message if the executable code has been patched, infected, or tampered with.</p>

<h2 id="physical-vs-loaded-state">Physical vs. loaded state</h2>

<p>The anatomy of the PE image is different, yet quite similar, in both (physical vs. loaded) PE states.</p>

<p>When a PE is loaded as a process, the PE image file gets chopped in sections, and these sections get relocated (copied) in memory:</p>

<ul>
<li>In both states, the PE image forms a block of contiguous bytes.</li>
<li>In both states, the header and the sections are found in the same order.</li>
<li>The amount of padding between sections usually differs.</li>
</ul>

<p>In their physical file form, PE sections do not need to have any particular padding, so EXE/DLL files can be as small as possible. On the other hand, when loaded, each PE section occupies a certain number of whole memory pages with certain permissions (execution, read-only, etc‚Ä¶). The amount of padding for the start address and the size of each section is given by the PE header.</p>

<p>It is important to note that this relocation procedure simply adds some padding between sections. The section chunks themselves remain identical, and are a straight copy of the original bytes found in the physical file. The only exceptions are some areas which get initialised by the Windows Loader on load (<em>e.g.,</em> some fields in the PE header, the IAT, ‚Ä¶). I will talk about these in a future post.</p>

<p><strong>[EDIT] I have made significant progress in this area in the 10+ years since I wrote this. But Part II of this post never saw the light of day. Spare time is scarce.</strong></p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/14/215617.html">Code fortification (2012-10-17)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/14/215617.html" class="u-url"><time class="dt-published" datetime="2022-01-14 22:56:00 &#43;0200">Jan 14, 2022</time></a>

        <div class="e-content">
         	<p><strong>[EDIT] This post was migrated from my blog from 2011&hellip;</strong></p>

<p>Lately, I‚Äôve been reading a lot about code fortification, and low-level debugging. Here are some of the most interesting links I‚Äôve found. They‚Äôre all worth reading if you fancy hardcore OS internals and such:</p>

<p><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2002/february/inside-windows-win32-portable-executable-file-format-in-detail">An In-Depth Look into the Win32 Portable Executable File Format</a></p>

<p><a href="https://docs.microsoft.com/en-us/previous-versions/ms809762(v=msdn.10)?redirectedfrom=MSDN">Peering Inside the PE: A Tour of the Win32 Portable Executable File Format</a></p>

<p><a href="https://code.google.com/archive/p/corkami/wikis/PE.wiki">The Portable Executable Format on Windows</a></p>

<p><a href="https://www.codeproject.com/Articles/43682/Writing-a-basic-Windows-debugger">Writing a basic Windows debugger (Part I)</a></p>

<p><a href="https://www.codeproject.com/Articles/132742/Writing-Windows-Debugger-Part-2">Writing a basic Windows debugger (Part II)</a></p>

<p><a href="https://www.codeproject.com/Articles/30815/An-Anti-Reverse-Engineering-Guide">An Anti-Reverse Engineering Guide</a></p>

<p><a href="https://www.codeproject.com/Articles/29469/Introduction-Into-Windows-Anti-Debugging">Introduction Into Windows Anti-Debugging</a></p>

<p><a href="http://sandsprite.com/CodeStuff/Understanding_imports.html">Understanding the Import Address Table</a></p>

<p><a href="https://pferrie.tripod.com/papers/unpackers.pdf">Anti-unpacker tricks</a></p>

<p>This all brings me back to my teenager years coding in x86 assembly language.</p>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/14/212534.html">Index-Of-Refraction (2011-10-15)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/14/212534.html" class="u-url"><time class="dt-published" datetime="2022-01-14 22:25:00 &#43;0200">Jan 14, 2022</time></a>

        <div class="e-content">
         	<p><strong>[EDIT] This post was migrated from my blog from 2011&hellip;</strong></p>

<p>This all below is stuff that kids study in school. :)</p>

<p>Below is a visualization of the behavior of a ray of light as it hits a dielectric interface.</p>

<p>Some key phenomena which show up in the video are:</p>

<ul>
<li>The <em>Fresnel</em> term (reflection vs. refraction).</li>
<li>The <em>Index of Refraction</em>.</li>
<li>The <em>critical angle</em>.</li>
<li><em>Total Internal Reflection</em> (TIR).</li>
<li>As nd increases the Index of Refraction becomes higher, and so does the Fresnel term, which defines the proportion between reflected and refracted light. The critical angle becomes higher too, so there is more Total Internal Reflection.</li>
</ul>

<p>When a ray of light hits an interface (assuming an ideal surface), all incident light must be either reflected or refracted. The Fresnel term (controlled by nd) tells how much light is reflected at a given incident angle. All the light that is not reflected is refracted, so both amounts (reflection and refraction) always add up to the total amount of incident light.</p>

<p>The Fresnel term approaches 1 at grazing angles (all light is reflected and nothing is refracted, regardless of nd) and is low (the lower the smaller the nd) at perpendicular angles (more light is refracted).</p>

<p>As a rule of thumb:</p>

<ul>
<li>The lower the nd, the lower the IOR, and the more transparent the surface (more glass/liquid-like).</li>
<li>The higher the nd, the higher the IOR, and the more reflective the surface (more metallic/mirror-like).</li>
</ul>

<p>For example:</p>

<ul>
<li>Void: nd=1.</li>
<li>Air: nd=1.1.</li>
<li>Water: nd=1.33.</li>
<li>Glass: nd=1.51.</li>
<li>Diamond: nd=2.5.</li>
<li>Metals: nd=20+. (approx. complex IOR).</li>
<li>Ideal mirror: nd=infinity.</li>
</ul>

<p>When a ray of light enters a medium with an nd lower than the nd of the previous medium, there is an angle at which the Fresnel term becomes 1 and beyond which light won‚Äôt refract anymore. This angle is called <em>critical angle</em>, and beyond it, the surface behaves like a perfect mirror, reflecting back all incident light. This effect is called <em>Total Internal Reflection</em> (TIR).</p>

<video controls="controls" playsinline="playsinline" src="https://www.brashandplucky.com/uploads/2022/0f9a215aa8.mov" width="640" height="213" poster="https://www.brashandplucky.com/uploads/2022/83b8d73cd8.png" preload="none"></video>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/14/edit-this-post.html">The cosine lobe (2021-10-12)</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/14/edit-this-post.html" class="u-url"><time class="dt-published" datetime="2022-01-14 22:12:00 &#43;0200">Jan 14, 2022</time></a>

        <div class="e-content">
         	<p><strong>[EDIT] This post was migrated from my blog from 2011&hellip;</strong></p>

<p>Testing image/video uploads.</p>

<video controls="controls" playsinline="playsinline" src="https://www.brashandplucky.com/uploads/2022/cf29dbceb3.mov" width="512" height="256" poster="https://www.brashandplucky.com/uploads/2022/968506d58e.png" preload="none"></video>

        </div>
      </div>
    
      <div class="h-entry">
		
			<h1><a href="https://www.brashandplucky.com/2022/01/14/hello-again.html">Hello again!</a></h1>
		

        <a href="https://www.brashandplucky.com/2022/01/14/hello-again.html" class="u-url"><time class="dt-published" datetime="2022-01-14 19:35:00 &#43;0200">Jan 14, 2022</time></a>

        <div class="e-content">
         	<p>Like most &ldquo;computer people&rdquo; I&rsquo;ve had some attempts over the years to manage a personal website, then a blog, then various social media accounts, etc&hellip; to quickly realize with each attempt that I don&rsquo;t have the time, and to some extent, the will or need to keep on posting. I am always way too busy for <em>non-productive</em> stuff.</p>

<p>On the other hand, pretty much like GitHub itself, there is some true value in archiving and organizing images, results, etc&hellip; of projects you&rsquo;ve worked on, even if just to build some sort of &ldquo;historical archive&rdquo; of your journey as a researcher.</p>

<p>I am certain that I won&rsquo;t be updating this micro-blog often (if at all). Mostly because my R&amp;D and management work at <a href="https://randomcontrol.com">RandomControl</a> (<a href="https://maverickrender.com">Maverick Render</a>) leaves me with basically no spare time. But I will try to &ldquo;now and then&rdquo; drop here some 3D/2D/physics code experiments and such.</p>

<p>I will start by transporting (some of) my very old <a href="https://chemaguerra.com">chemaguerra.com</a> blog from 2011 to micro-posts here.</p>

<p>Godspeed!</p>

        </div>
      </div>
    

</div>


    
    

  </body>

</html>
